<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLP Service Demo</title>
    <style>
        /* Basic Reset & Body Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
             /* Container and Header */
        .container {
            max-width: 900px;
            margin: 30px auto;
            background-color: #ffffff;
            padding: 30px 40px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 600;
            letter-spacing: -0.5px;
        }
              /* Input Area Styling */
        .input-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #eaf3f1;
            border-radius: 8px;
            border: 1px dashed #b2dfdb;
        }

        textarea {
            width: calc(100% - 20px);
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #b2dfdb;
            border-radius: 8px;
            font-size: 1em;
            resize: vertical;
            min-height: 100px;
            box-sizing: border-box;
        }

        button {
            display: block;
            width: 100%;
            padding: 14px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }
              /* Results Area Styling */
        .results-section {
            margin-top: 30px;
            background-color: #f8f8f8;
            padding: 25px;
            border-radius: 8px;
            border: 1px solid #ececec;
        }

        .results-section h2 {
            color: #34495e;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid #cfd8dc;
            padding-bottom: 10px;
        }

        .result-box {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-left: 5px solid #4CAF50;
            padding: 18px;
            margin-bottom: 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .result-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .result-box strong {
            color: #2c3e50;
            font-size: 1.1em;
            display: block;
            margin-bottom: 8px;
        }

        .result-box pre {
            background-color: #eef;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            border: 1px dashed #d0d0ed;
        }
             /* Specific result box colors */
        #sentimentResult .result-box { border-left-color: #28a745; }
        #entitiesResult .result-box { border-left-color: #17a2b8; }
        #posResult .result-box { border-left-color: #ffc107; }
        #summaryResult .result-box { border-left-color: #6f42c1; }
        #topicsResult .result-box { border-left-color: #dc3545; }
        #answerResult .result-box { border-left-color: #fd7e14; }
        #generatedTextResult .result-box { border-left-color: #20c997; }
        #chatResponseResult .result-box { border-left-color: #6610f2; }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                margin: 15px auto;
                padding: 20px 25px;
            }
            h1 {
                font-size: 2em;
            }
            button {
                font-size: 1em;
                padding: 12px 15px;
            }
        }
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px 20px;
            }
            h1 {
                font-size: 1.8em;
            }
            textarea {
                min-height: 80px;
            }
        }
    </style>
</head>
 <body>
    <div class="container">
        <h1>NLP Service Demo</h1>

        <div class="input-section">
            <label for="inputText">Enter your text here:</label>
            <textarea id="inputText" placeholder="Type or paste text for NLP analysis..."></textarea>

            <label for="inputQuestion">Enter a question (for QA):</label>
            <textarea id="inputQuestion" placeholder="e.g., What is the capital of France? (requires context in main text area)"></textarea>

            <button onclick="runNLP()">Analyze Text</button>
        </div>

        <div class="results-section">
            <h2>NLP Results</h2>
            <div id="sentimentResult" class="result-box">
                <strong>Sentiment Analysis:</strong>
                <pre id="sentimentOutput"></pre>
            </div>
            <div id="entitiesResult" class="result-box">
                <strong>Named Entities:</strong>
                <pre id="entitiesOutput"></pre>
            </div>
            <div id="posResult" class="result-box">
                <strong>Tokens and POS Tags:</strong>
                <pre id="posOutput"></pre>
            </div>
            <div id="summaryResult" class="result-box">
                <strong>Text Summary (30%):</strong>
                <pre id="summaryOutput"></pre>
            </div>
            <div id="topicsResult" class="result-box">
                <strong>Extracted Topics:</strong>
                <pre id="topicsOutput"></pre>
            </div>
            <div id="answerResult" class="result-box">
                <strong>Question Answering:</strong>
                <pre id="answerOutput"></pre>
            </div>
            <div id="generatedTextResult" class="result-box">
                <strong>Generated Text:</strong>
                <pre id="generatedTextOutput"></pre>
            </div>
            <div id="chatResponseResult" class="result-box">
                <strong>Chatbot Response:</strong>
                <pre id="chatResponseOutput"></pre>
            </div>
        </div>
    </div>
       <script>
        class NLPService {
            constructor() {
                // Predefined sentiment words
                this.sentimentWords = {
                    positive: [
                        "good", "great", "excellent", "happy", "love", "awesome", "fantastic",
                        "wonderful", "amazing", "beautiful", "bright", "cheer", "delight",
                        "enthusiasm", "excitement", "freedom", "glorious", "harmony", "joy",
                        "kindness", "laughter", "optimism", "peace", "pleasure", "radiant",
                        "serenity", "success", "thrill", "upbeat", "vibrant", "warmth", "zeal"
                    ],
                    negative: [
                        "bad", "poor", "terrible", "sad", "hate", "awful", "horrible", "ugly",
                        "dark", "gloom", "stress", "fear", "anger", "anxiety", "confusion",
                        "crisis", "disaster", "disappointment", "distress", "failure", "grief",
                        "hardship", "insecurity", "loneliness", "misery", "neglect", "pain",
                        "regret", "sorrow", "tragedy", "unhappy", "worry"
                    ],
                    neutral: [
                        "neutral", "okay", "alright", "indifferent", "plain", "calm", "balanced",
                        "stable", "steady", "normal", "typical", "regular", "ordinary", "simple",
                        "common", "even", "fair", "average"
                    ],
                    question: ["what", "where", "when", "why", "how", "who", "which", "is", "are", "do", "does", "can", "could", "will", "would", "should", "did"]
                };
                              this.responseTemplates = {
                    greeting: [
                        "Hello there! How can I assist you today?",
                        "Hi! It's great to hear from you.",
                        "Hey! What can I do for you?",
                        "Greetings! Ready to help."
                    ],
                    positive: [
                        "That's wonderful! Your optimism is contagious.",
                        "Great to see such positive energy in your message!"
                    ],
                    negative: [
                        "I sense some negativity in your message. Is there something I can help with?",
                        "Your message seems to express some concerns. Would you like to talk about it?",
                        "I notice a negative sentiment. I'm here to help if you need support.",
                        "That sounds challenging. How can I assist you?"
                    ],
                    neutral: [
                        "I understand. Let me help you with that.",
                        "That's an interesting point. Tell me more.",
                        "I see what you mean. How can I assist further?",
                        "Thank you for sharing that with me."
                    ],
                    question: [
                        "That's a great question! Based on what you're asking, let me think about that.",
                        "Interesting question! I'd be happy to help you explore that topic.",
                        "Good question! Let me consider what I can tell you about that.",
                        "That's something worth discussing! What specifically interests you about this topic?"
                    ]
                };
            }
                      // Sentiment Analysis
            analyzeSentiment(text) {
                if (!text || text.trim().length === 0) {
                    return { polarity: 0, subjectivity: 0, label: 'Neutral' };
                }

                const words = text.toLowerCase().match(/\b\w+\b/g) || [];
                let positiveScore = 0;
                let negativeScore = 0;
                let subjectiveWords = 0;

                words.forEach(word => {
                    if (this.sentimentWords.positive.includes(word)) {
                        positiveScore += 1;
                        subjectiveWords += 1;
                    } else if (this.sentimentWords.negative.includes(word)) {
                        negativeScore += 1;
                        subjectiveWords += 1;
                    }
                });

                const totalWords = words.length;
                const netScore = positiveScore - negativeScore;
                const polarity = totalWords > 0 ? netScore / totalWords : 0;
                const subjectivity = totalWords > 0 ? subjectiveWords / totalWords : 0;

                let label = 'Neutral';
                if (polarity > 0.1) label = 'Positive';
                else if (polarity < -0.1) label = 'Negative';

                return {
                    polarity: Math.max(-1, Math.min(1, polarity * 5)),
                    subjectivity: Math.min(1, subjectivity * 2),
                    label: label,
                    positiveWords: positiveScore,
                    negativeWords: negativeScore
                };
            }

            // Named Entity Recognition (simplified)
            extractEntities(text) {
                if (!text || text.trim().length === 0) {
                    return [];
                }

                const entities = [];

                const personPattern = /\b(?:Mr\.?|Mrs\.?|Ms\.?|Dr\.?|Prof\.?)\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g;
                const persons = text.match(personPattern) || [];
                persons.forEach(person => {
                    entities.push({ text: person.trim(), label: 'PERSON', description: 'Person name' });
                });

                const namePattern = /\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+\b/g;
                const names = text.match(namePattern) || [];
                names.forEach(name => {
                    if (!persons.some(p => p.includes(name))) {
                        entities.push({ text: name, label: 'PERSON', description: 'Possible person name' });
                    }
                });

                const orgPattern = /\b[A-Z][a-z]*(?:\s+[A-Z][a-z]*)*\s+(?:Inc\.?|Corp\.?|LLC|Ltd\.?|Company|Corporation|University|College|School|Hospital|Bank|Group|Foundation|Institute)\b/g;
                const orgs = text.match(orgPattern) || [];
                orgs.forEach(org => {
                    entities.push({ text: org, label: 'ORG', description: 'Organization' });
                });

                const datePattern = /\b(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},?\s+\d{4}\b|\b\d{1,2}\/\d{1,2}\/\d{2,4}\b|\b\d{4}-\d{2}-\d{2}\b/g;
                const dates = text.match(datePattern) || [];
                dates.forEach(date => {
                    entities.push({ text: date, label: 'DATE', description: 'Date' });
                });

                const moneyPattern = /\$\d+(?:,\d{3})*(?:\.\d{2})?\b|\b\d+(?:,\d{3})*(?:\.\d{2})?\s+(?:dollars?|USD|euros?|EUR|pounds?|GBP)\b/g;
                const money = text.match(moneyPattern) || [];
                money.forEach(amount => {
                    entities.push({ text: amount, label: 'MONEY', description: 'Monetary amount' });
                });

                const locations = [
                    'United States', 'Canada', 'Mexico', 'Brazil', 'Argentina', 'United Kingdom',
                    'France', 'Germany', 'Italy', 'Spain', 'Russia', 'China', 'Japan', 'India',
                    'Australia', 'New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix',
                    'Philadelphia', 'San Antonio', 'San Diego', 'Dallas', 'San Jose', 'Austin',
                    'London', 'Paris', 'Berlin', 'Rome', 'Madrid', 'Moscow', 'Tokyo', 'Beijing',
                    'California', 'Texas', 'Florida', 'New York', 'Pennsylvania', 'Illinois',
                    'Madurai', 'Tamil Nadu'
                ];

                locations.forEach(location => {
                    const regex = new RegExp(`\\b${location}\\b`, 'gi');
                    const matches = text.match(regex) || [];
                    matches.forEach(match => {
                        entities.push({ text: match, label: 'GPE', description: 'Geopolitical entity' });
                    });
                });

                return entities;
            }

            tokenizeAndPOS(text) {
                if (!text || text.trim().length === 0) {
                    return [];
                }

                const tokens = text.match(/\b\w+\b/g) || [];
                const result = [];

                tokens.forEach(token => {
                    const pos = this.simplePOSTag(token);
                    result.push({ text: token, pos: pos, lemma: token.toLowerCase() });
                });

                return result;
            }

            simplePOSTag(word) {
                const lowerWord = word.toLowerCase();

                if (['the', 'a', 'an', 'this', 'that', 'these', 'those'].includes(lowerWord)) return 'DET';
                if (['i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them'].includes(lowerWord)) return 'PRON';
                if (['is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did'].includes(lowerWord)) return 'VERB';
                if (['in', 'on', 'at', 'by', 'for', 'with', 'to', 'from', 'of', 'about'].includes(lowerWord)) return 'ADP';
                if (['and', 'or', 'but', 'so', 'because', 'although', 'if', 'when'].includes(lowerWord)) return 'CONJ';
                if (lowerWord.endsWith('ing')) return 'VERB';
                if (lowerWord.endsWith('ed')) return 'VERB';
                if (lowerWord.endsWith('ly')) return 'ADV';
                if (lowerWord.endsWith('ful') || lowerWord.endsWith('less') || lowerWord.endsWith('ous')) return 'ADJ';
                if (word[0] === word[0].toUpperCase() && word.length > 1) return 'PROPN';

                return 'NOUN';
          }
                     // Text Generation
            generateText(prompt, maxLength = 200) {
                if (!prompt || prompt.trim().length === 0) {
                    return "Please provide a prompt for text generation.";
                }

                const templates = [
                    "Based on your input, here's a continuation: ",
                    "Expanding on that thought: ",
                    "To elaborate further: ",
                    "This leads to the consideration that: "
                ];

                const words = prompt.toLowerCase().split(' ');
                let continuation = "";

                if (words.some(word => ['story', 'once', 'character', 'plot'].includes(word))) {
                    continuation = this.generateStoryContinuation();
                } else if (words.some(word => ['science', 'research', 'study', 'analysis'].includes(word))) {
                    continuation = this.generateAcademicContinuation();
                } else {
                    continuation = this.generateGeneralContinuation();
                }

                const template = templates[Math.floor(Math.random() * templates.length)];
                const fullText = prompt + " " + template + continuation;

                const wordArray = fullText.split(' ');
                if (wordArray.length > maxLength) {
                    return wordArray.slice(0, maxLength).join(' ') + "...";
                }

                return fullText;
            }

            generateStoryContinuation() {
                const continuations = [
                    "The story unfolds with unexpected twists and turns, revealing hidden depths in the characters' motivations.",
                    "As the narrative progresses, new challenges emerge that test the protagonist's resolve and determination.",
                    "The plot thickens with each passing moment, drawing readers deeper into the intricate web of relationships and conflicts.",
                    "What follows is a journey of discovery, where each revelation builds upon the last to create a compelling narrative arc."
                ];
                return continuations[Math.floor(Math.random() * continuations.length)];
            }

            generateAcademicContinuation() {
                const continuations = [
                    "This research contributes to our understanding of the underlying mechanisms and provides insights for future investigations.",
                    "The findings suggest important implications for both theoretical frameworks and practical applications in the field.",
                    "Further analysis reveals patterns that warrant deeper investigation and systematic study.",
                    "These observations form the foundation for developing more comprehensive models and methodological approaches."
                ];
                return continuations[Math.floor(Math.random() * continuations.length)];
            }

            generateGeneralContinuation() {
                const continuations = [
                    "This topic opens up numerous possibilities for exploration and discussion, each offering unique perspectives.",
                    "The implications of this extend far beyond the initial scope, touching on various aspects of modern society.",
                    "Understanding this concept requires examining multiple factors and their interconnected relationships.",
                    "The significance of this cannot be overstated, as it influences many aspects of our daily experiences."
                ];
                return continuations[Math.floor(Math.random() * continuations.length)];
            }

            // Question Answering
            answerQuestion(question, context) {
                if (!question || !context) {
                    return { answer: null, confidence: 0 };
                }

                const questionWords = question.toLowerCase().split(' ').filter(word => word.length > 2);
                const sentences = context.split(/[.!?]+/).filter(s => s.trim().length > 0);

                let bestSentence = "";
                let bestScore = 0;

                sentences.forEach(sentence => {
                    const sentenceLower = sentence.toLowerCase();
                    let score = 0;

                    questionWords.forEach(word => {
                        if (sentenceLower.includes(word)) {
                            score += 1;
                        }
                    });

                    if (score > bestScore) {
                        bestScore = score;
                        bestSentence = sentence.trim();
                    }
                });

                const confidence = questionWords.length > 0 ? bestScore / questionWords.length : 0;

                return {
                    answer: bestSentence || "No relevant answer found in the context.",
                    confidence: Math.min(confidence, 1.0),
                    context: bestSentence
                };
            }

            // Text Summarization
            summarizeText(text, ratio = 0.3) {
                if (!text || text.trim().length === 0) {
                    return "No text provided for summarization.";
                }

                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);

                if (sentences.length <= 2) {
                    return text;
                }

                const words = text.toLowerCase().match(/\b\w+\b/g) || [];
                const wordFreq = {};

                words.forEach(word => {
                    if (word.length > 3) {
                        wordFreq[word] = (wordFreq[word] || 0) + 1;
                    }
                });

                const sentenceScores = sentences.map(sentence => {
                    const sentWords = sentence.toLowerCase().match(/\b\w+\b/g) || [];
                    let score = 0;

                    sentWords.forEach(word => {
                        if (wordFreq[word]) {
                            score += wordFreq[word];
                        }
                    });

                    return { sentence: sentence.trim(), score: score };
                });

                sentenceScores.sort((a, b) => b.score - a.score);
                const numSentences = Math.max(1, Math.floor(sentences.length * ratio));
                const topSentences = sentenceScores.slice(0, numSentences);

                const summary = sentences.filter(sentence =>
                    topSentences.some(ts => ts.sentence === sentence.trim())
                );

                return summary.join('. ') + '.';
            }
                      // Topic Modeling (simplified)
            extractTopics(text, numTopics = 3) {
                if (!text || text.trim().length === 0) {
                    return { topics: [], wordFreq: {} };
                }

                const words = text.toLowerCase().match(/\b\w+\b/g) || [];
                const stopWords = new Set([
                    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                    'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have',
                    'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should',
                    'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
                    'my', 'your', 'his', 'her', 'its', 'our', 'their', 'this', 'that', 'these', 'those',
                    'am', 'can', 'get', 'just', 'like', 'make', 'not', 'now', 'only', 'out', 'say',
                    'see', 'some', 'than', 'then', 'there', 'these', 'they', 'this', 'time', 'two',
                    'up', 'use', 'very', 'want', 'way', 'well', 'what', 'when', 'where', 'which',
                    'who', 'why', 'will', 'with', 'would', 'your', 'from', 'about', 'into', 'over',
                    'after', 'before', 'above', 'below', 'between', 'through', 'during', 'without',
                    'under', 'around', 'among', 'amongst', 'along', 'across', 'behind', 'below',
                    'beneath', 'beside', 'besides', 'between', 'beyond', 'by', 'down', 'during',
                    'except', 'for', 'from', 'inside', 'into', 'near', 'off', 'on', 'onto', 'out',
                    'outside', 'over', 'past', 'round', 'since', 'than', 'through', 'to', 'toward',
                    'under', 'underneath', 'until', 'up', 'upon', 'with', 'within', 'without', 'etc'
                ]);

                const filteredWords = words.filter(word =>
                    word.length > 3 && !stopWords.has(word)
                );

                const wordFreq = {};
                filteredWords.forEach(word => {
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                });

                const sortedWords = Object.entries(wordFreq)
                    .sort(([,a], [,b]) => b - a);

                const topics = [];
                const wordsPerTopic = Math.max(1, Math.floor(sortedWords.length / numTopics));

                for (let i = 0; i < numTopics && i * wordsPerTopic < sortedWords.length; i++) {
                    const topicWords = sortedWords
                        .slice(i * wordsPerTopic, (i + 1) * wordsPerTopic)
                        .slice(0, 5)
                        .map(([word]) => word);

                    if (topicWords.length > 0) {
                        topics.push(topicWords);
                    }
                }

                return {
                    topics: topics,
                    wordFreq: Object.fromEntries(sortedWords.slice(0, 20))
                };
            }

            // Chatbot Response Generation
            generateChatResponse(userInput) {
                const analysis = this.analyzeSentiment(userInput);
                const entities = this.extractEntities(userInput);
                const lowerInput = userInput.toLowerCase();

                if (this.isGreeting(lowerInput)) {
                    return { response: this.getRandomResponse('greeting'), analysis: { sentiment: analysis.label, entities: entities } };
                }

                if (this.isQuestion(lowerInput)) {
                    return { response: this.getRandomResponse('question'), analysis: { sentiment: analysis.label, entities: entities } };
                }

                let responseType = 'neutral';
                if (analysis.label === 'Positive') responseType = 'positive';
                else if (analysis.label === 'Negative') responseType = 'negative';

                return { response: this.getRandomResponse(responseType), analysis: { sentiment: analysis.label, entities: entities } };
            }

            isGreeting(text) {
                const greetingPatterns = [
                    'hello', 'hi', 'hey', 'greetings', 'good morning',
                    'good afternoon', 'good evening', 'how are you', 'how are things', 'sup'
                ];
                return greetingPatterns.some(pattern => text.includes(pattern));
            }

            isQuestion(text) {
                const questionWords = ['what', 'how', 'why', 'when', 'where', 'who', 'can you', 'will you', 'is it', 'are you'];
                return questionWords.some(word => text.includes(word)) || text.includes('?');
            }

            getRandomResponse(type) {
                const responses = this.responseTemplates[type] || this.responseTemplates.neutral;
                return responses[Math.floor(Math.random() * responses.length)];
            }
        }
                 // Global instance of NLPService
        const nlpService = new NLPService();

        // Function to run NLP analysis and update UI
        function runNLP() {
            const inputText = document.getElementById('inputText').value;
            const inputQuestion = document.getElementById('inputQuestion').value;

            // Clear previous outputs
            document.getElementById('sentimentOutput').textContent = '';
            document.getElementById('entitiesOutput').textContent = '';
            document.getElementById('posOutput').textContent = '';
            document.getElementById('summaryOutput').textContent = '';
            document.getElementById('topicsOutput').textContent = '';
            document.getElementById('answerOutput').textContent = '';
            document.getElementById('generatedTextOutput').textContent = '';
            document.getElementById('chatResponseOutput').textContent = '';


            if (!inputText.trim()) {
                alert("Please enter some text to analyze!");
                return;
            }

            // Sentiment Analysis
            const sentiment = nlpService.analyzeSentiment(inputText);
            document.getElementById('sentimentOutput').textContent = JSON.stringify(sentiment, null, 2);

            // Named Entity Recognition
            const entities = nlpService.extractEntities(inputText);
            document.getElementById('entitiesOutput').textContent = JSON.stringify(entities, null, 2);

            // Tokenization and POS Tagging
            const pos = nlpService.tokenizeAndPOS(inputText);
            document.getElementById('posOutput').textContent = JSON.stringify(pos, null, 2);

            // Text Summarization
            const summary = nlpService.summarizeText(inputText);
            document.getElementById('summaryOutput').textContent = summary;

            // Topic Modeling
            const topics = nlpService.extractTopics(inputText);
            document.getElementById('topicsOutput').textContent = JSON.stringify(topics, null, 2);

            // Question Answering (if a question is provided)
            if (inputQuestion.trim()) {
                const answer = nlpService.answerQuestion(inputQuestion, inputText);
                document.getElementById('answerOutput').textContent = JSON.stringify(answer, null, 2);
            } else {
                 document.getElementById('answerOutput').textContent = "Enter a question above to get an answer based on the main text.";
            }

            // Text Generation (using the input text as a prompt)
            const generatedText = nlpService.generateText(inputText, 150);
            document.getElementById('generatedTextOutput').textContent = generatedText;

            // Chatbot Response Generation (using the input text as user input)
            const chatResponse = nlpService.generateChatResponse(inputText);
            document.getElementById('chatResponseOutput').textContent = `Response: "${chatResponse.response}"\nAnalysis: ${JSON.stringify(chatResponse.analysis, null, 2)}`;
        }
    </script>
</body>
</html>
